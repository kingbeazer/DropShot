@using System.ComponentModel.DataAnnotations
@using DropShot.Models;
@using DropShot.Data;
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.EntityFrameworkCore
@using System;
@using System.Collections.Generic
@using System.Text.Json
@using Newtonsoft.Json
@using MudBlazor
@using System.Threading

@page "/tennisscore"
@rendermode InteractiveServer
 
@inject MyDbContext DbContext
@inject NavigationManager Navigation
@inject UserState State
@inject IDialogService Dialog
@inject IDialogService DialogService
@inject NavigationManager NavigationManager

<MudCollapse Expanded="_expanded" Style="margin-top: 10px;">
    <MudPaper Class="pa-4">
        <MudStack Spacing="2">
            <MudText>Settings</MudText>
            <MudDivider />
            <MudSwitch @bind-Value="gameScoring" Label="Game Scoring" LabelPlacement="Placement.Start" Color="Color.Success" />
            <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Save" Color="Color.Info" Size="Size.Small" OnClick="@OnExpandCollapseClick">Save</MudButton>
            <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Cancel" Color="Color.Error" Size="Size.Small" OnClick="@(() => OpenDialogAsync(_fullScreen))">End Match</MudButton>
        </MudStack>
    </MudPaper>
</MudCollapse>

@if (loaded && CurrentMatch == null)
{
    <MudSwitch @bind-Value="Label_Switch1" Label="Doubles" Color="Color.Success" />

    <MudAutocomplete @bind-Value="_value"
                     Label="Player 1"
                     SearchFunc="@Search1"
                     ResetValueOnEmptyText="@resetValueOnEmptyText"
                     Variant="Variant.Outlined"
                     CoerceText="@coerceText"
                     Margin="_margin"
                     Dense="_dense"
                     CoerceValue="true"
                     Placeholder="@(_placeholder ? "Placeholder" : null)"
                     SelectValueOnTab="@selectedOnTab"
                     AdornmentColor="Color.Primary" />
    @if (!Label_Switch1)
    {
        <MudText Typo="Typo.h1">vs</MudText>
    }
    <MudAutocomplete @bind-Value="_value2"
                     Label="Player 2"
                     SearchFunc="@Search1"
                     ResetValueOnEmptyText="@resetValueOnEmptyText"
                     Variant="Variant.Outlined"
                     CoerceText="@coerceText"
                     Margin="_margin"
                     Dense="_dense"
                     CoerceValue="true"
                     Placeholder="@(_placeholder ? "Placeholder" : null)"
                     SelectValueOnTab="@selectedOnTab"
                     AdornmentColor="Color.Primary" />

    @if (Label_Switch1)
    {
        <MudText Typo="Typo.h1">vs</MudText>
    }

    @if (Label_Switch1)
    {
        <MudAutocomplete @bind-Value="_value3"
                         Label="Player 3"
                         SearchFunc="@Search1"
                         ResetValueOnEmptyText="@resetValueOnEmptyText"
                         Variant="Variant.Outlined"
                         CoerceText="@coerceText"
                         Margin="_margin"
                         Dense="_dense"
                         CoerceValue="true"
                         Placeholder="@(_placeholder ? "Placeholder" : null)"
                         SelectValueOnTab="@selectedOnTab"
                         AdornmentColor="Color.Primary" />

        <MudAutocomplete @bind-Value="_value4"
                         Label="Player 4"
                         SearchFunc="@Search1"
                         ResetValueOnEmptyText="@resetValueOnEmptyText"
                         Variant="Variant.Outlined"
                         CoerceText="@coerceText"
                         Margin="_margin"
                         Dense="_dense"
                         CoerceValue="true"
                         Placeholder="@(_placeholder ? "Placeholder" : null)"
                         SelectValueOnTab="@selectedOnTab"
                         AdornmentColor="Color.Primary" />
    }

    <MudButton Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.PlayArrow" Style="margin: 10px;" OnClick="ButtonOnClick">Start Match</MudButton>
}

@if(loaded && @CurrentMatch != null)
{
      <section class="bg-tennis overlay-dark">
    <div class="score-container">
        <!-- Top Player Button -->
        <div style="display: flex">
            <MudAvatarGroup Max="3" Spacing="5" MaxColor="Color.Primary">
                    <MudAvatar @onclick="UserWinsPoint" disabled="@isMatchEnded" Style="border: solid 1px lightseagreen; width:60px; height: 60px; touch-action: pan-x pan-y;">
                <MudImage Src="images/me.png"></MudImage>
                <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                                    color:white; font-size:20px; font-weight:bold;">
                        @CurrentMatch.Player1.GetInitials()
                </div>
            </MudAvatar>
                        <MudAvatar Style="border: solid 1px lightseagreen; width:60px; height: 60px;">
                        <MudIcon Icon="@Icons.Material.Filled.KeyboardDoubleArrowUp" />
                        </MudAvatar>
                </MudAvatarGroup>
           
            @if (Label_Switch1)
            {
                    <MudAvatar @onclick="UserWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px lightseagreen; width:60px; height: 60px; margin-left: -15px;">
                    <MudImage Src="images/me.png" @onclick="UserWinsPoint"></MudImage>
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                                            color:white; font-size:20px; font-weight:bold;">
                            @CurrentMatch.Player2.GetInitials()
                    </div>
                </MudAvatar>
            }
        </div>
        <!-- Score Display -->
        <div class="score-display">
            <div class="score-row">

                @if (isUserServing)
                {
                    <span class="sets serve-indicator">🎾</span>
                }
                else
                {
                    <span class="sets serve-indicator"></span>
                }

                @foreach (var set in setScores)
                {
                    <span class="sets">@set.UserGames</span>
                }
                @if (!isMatchEnded)
                {
                    <span class="sets">@userGames</span>
                }
                @if (!gameScoring || isTieBreak)
                {
                    <span class="sets">@ScoreDisplayUser</span>
                }
            </div>
            <div class="score-row">

                @if (!isUserServing)
                {
                    <span class="sets serve-indicator">🎾</span>
                }
                else
                {
                    <span class="sets serve-indicator"></span>
                }

                @foreach (var set in setScores)
                {
                    <span class="sets">@set.OpponentGames </span>
                }

                @if (!isMatchEnded)
                {
                    <span class="sets">@opponentGames</span>
                }

                @if (!gameScoring || isTieBreak)
                {
                    <span class="sets">@ScoreDisplayOpp</span>
                }
            </div>


            <!-- Settings Button (Bottom Left) -->
                <button class="settings-btn" @onclick="@OnExpandCollapseClick">
                <MudIcon Icon="@Icons.Material.Filled.Settings" Title="Favorite" Size="Size.Large" />  
            </button>

            <!-- Undo Button (Bottom Right) -->
            <button class="undo-btn" @onclick="UndoLastPoint">
                <MudIcon Icon="@Icons.Material.Filled.Undo" Title="Favorite" Size="Size.Large" />
            </button>

        </div>

        <!-- Bottom Player Button -->
        <div style="display: flex">
            @if (Label_Switch1)
            {
                    <MudAvatar @onclick="OpponentWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px orangered; width:60px; height: 60px;">
                    <MudImage Src="images/me.png"></MudImage>
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                                color:white; font-size:20px; font-weight:bold;">
                            @CurrentMatch.Player3.GetInitials()
                    </div>
                </MudAvatar>
                    <MudAvatar @onclick="OpponentWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px orangered; width:60px; height: 60px; margin-left: -15px;">
                    <MudImage Src="images/me.png"></MudImage>
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                                color:white; font-size:20px; font-weight:bold;">
                            @CurrentMatch.Player4.GetInitials()
                    </div>
                </MudAvatar>
            }
            else
            {
                    <MudAvatar @onclick="OpponentWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px orangered; width:60px; height: 60px;">
                    <MudImage Src="images/me.png"></MudImage>
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                        color:white; font-size:20px; font-weight:bold;">
                            @CurrentMatch.Player2.GetInitials()
                    </div>
                </MudAvatar>

              @*   <button name="btnOppWinsPoint" class="initial-circle" style="color: lightseagreen; border-color: lightseagreen" >
                    <MudImage Src="images/me.png" Alt="Mony the dog" ObjectFit="@ObjectFit.Contain" Elevation="25" Class="rounded-lg" />
                </button> *@

            }
        </div>
    </div>
    </section>
   
}

<div style="margin: 10px;"></div>

@if (@CurrentMatch != null && @CurrentMatch.Complete)
{
    if (!string.IsNullOrWhiteSpace(_winner) && !_winner.Equals("Congratulations "))
    {
        <MudAlert Style="margin-top: 10px;" Severity="Severity.Success">@_winner</MudAlert>
    }
    <MudButton Style="margin-top: 10px;" FullWidth=true Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.FiberNew" Color="Color.Secondary" Size="Size.Large" OnClick="@ReloadPage">Start New Match</MudButton>
}

@code {
    private string _value;
    private string _value2;
    private string _value3;
    private string _value4;
    private string _winner;
    private Margin _margin;
    private bool _dense;
    private bool _disabled;
    private bool _readonly;
    private bool _placeholder;
    private bool _helperText;
    private bool _helperTextOnFocus;
    private bool _clearable;
    private bool _modal = true;
    private string Image = "images/me.png";


    private bool resetValueOnEmptyText;
    private bool coerceText;
    private bool coerceValue;
    private bool selectedOnTab;

    bool _expanded = false;

    private void OnExpandCollapseClick()
    {
        _expanded = !_expanded;
    }

    private readonly DialogOptions _maxWidth = new() { MaxWidth = MaxWidth.Medium, FullWidth = true };
    private readonly DialogOptions _closeButton = new() { CloseButton = true };
    private readonly DialogOptions _noHeader = new() { NoHeader = true };
    private readonly DialogOptions _backdropClick = new() { BackdropClick = false };
    private readonly DialogOptions _fullScreen = new() { FullScreen = false, CloseButton = true };
    private readonly DialogOptions _topCenter = new() { Position = DialogPosition.TopCenter };



    private async Task OpenDialogAsync(DialogOptions options)
    {
        var dialog = await DialogService.ShowAsync<EndMatch>("Delete Server", options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            OnExpandCollapseClick();
            EndMatch();
        }
    }

    // Change ReloadPage from static to instance method to fix CS0120
    public void ReloadPage()
    {
        history = new(new[] { new GameState(0, 0, 0, 0, 0, 0, false, 0, false, 0, 0, new List<SetScore>(), DateTime.Now, false) });

        _value = "";
        _value2 = "";
        _value3 = "";
        _value4 = "";
        _winner = "";
        opponentGames = 0;
        userGames = 0;
        setScores.Clear();
        userSets = 0;
        opponentSets = 0;
        isMatchEnded = false;
        CurrentMatch = null;

    }

    private async Task<IEnumerable<string>> Search1(string value, CancellationToken token)
    {
        // In real life use an asynchronous function for fetching data from an api.
        await Task.Delay(5, token);

        // if text is null or empty, show complete list
        if (string.IsNullOrEmpty(value))
            return _states;
        return _states.Where(x => x.Contains(value, StringComparison.InvariantCultureIgnoreCase));
    }

    private async Task<IEnumerable<string>> Search2(string value, CancellationToken token)
    {
        // In real life use an asynchronous function for fetching data from an api.
        await Task.Delay(5, token);

        // if text is null or empty, don't return values (drop-down will not open)
        if (string.IsNullOrEmpty(value))
            return new string[0];
        return _states.Where(x => x.Contains(value, StringComparison.InvariantCultureIgnoreCase));
    }


    public bool Label_Switch1 { get; set; } = false;

    void ButtonOnClick()
    {
        CurrentMatch = new Match
        {
            History = history,
            Player1 = _value,
            Player2 = _value2,
            Player3 = _value3,
            Player4 = _value4
        };
    }

    private string[] _states =
    {
        "Alan Beattie", "Andrew Beattie", "Mark Buchner", "Kevin Beattie", "Ronald Beattie",
        "Ian Kerr", "James Daniel"
    };

    private async Task<IEnumerable<string>> Search(string value, CancellationToken token)
    {
        // In real life use an asynchronous function for fetching data from an api.
        await Task.Delay(5, token);

        // if text is null or empty, show complete list
        if (string.IsNullOrEmpty(value))
        {
            return new List<string>();
        }

        return _states.Where(x => x.Contains(value, StringComparison.InvariantCultureIgnoreCase));
    }

    private int userPoints = 0;
    private int opponentPoints = 0;
    private int userGames = 0;
    private int opponentGames = 0;
    private int userSets = 0;
    private int opponentSets = 0;
    private bool isTieBreak = false;
    private int bestOf = 5;
    private int gamesFirstTo = 6;
    private bool gameScoring = true;
    private int maxDeuce = 99999;
    private bool isUserServing = true; // Start with user serving
    private List<Score> scores = new();
    private HubConnection? hubConnection;
    private bool matchGo = false;
    private bool loaded = false;

    private Match _currentMatch;
    public Match CurrentMatch
    {
        get => _currentMatch;
        set
        {
            _currentMatch = value;
            // Breakpoint here
        }
    }


    protected override async Task OnInitializedAsync()
    {
        // using var dbc = DbFactory.CreateDbContext();
        if (hubConnection is not null)
        {
            loaded = true;
            return;
        }

        var savedMatch = await DbContext.SavedMatch
            .FirstOrDefaultAsync(m => !m.Complete);

        // Fix CS8602: Check for null before dereferencing savedMatch
        if (savedMatch != null && !string.IsNullOrEmpty(savedMatch.MatchJson))
        {
            // Fix CS0266: Specify the type parameter for DeserializeObject
            // Fix CS8601: Use null-forgiving operator if you are sure MatchJson is not null, or handle null

            if (CurrentMatch == null)
            {
                CurrentMatch = JsonConvert.DeserializeObject<Match>(savedMatch.MatchJson) ?? new Match();
            }
            history = new Stack<GameState>(CurrentMatch.HistoryList.AsEnumerable().Reverse());

            if (history.Any())
            {
                var last = history.Peek();
                userPoints = last.UserPts;
                opponentPoints = last.OppPts;
                userGames = last.UserG;
                opponentGames = last.OppG;
                userSets = last.UserS;
                opponentSets = last.OppS;
                isTieBreak = last.TieBreak;
                deuceCount = last.DeuceCount;
                isMatchEnded = false;
                isUserServing = last.IsUserServing;
                setScores = last.SetScores != null ? last.SetScores.Select(s => s.Clone()).ToList() : new List<SetScore>();
                isMatchEnded = last.isComplete;
            }
        }

        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/chathub"))
            .Build();

        // hubConnection.On<string, string>("ReceiveMessage", async (user, message) =>
        // {
        //     scores = await dbc.Score.ToListAsync();

        //     await InvokeAsync(StateHasChanged);
        // });

        await hubConnection.StartAsync();
        loaded = true;
    }

    private int deuceCount = 0;
    private bool isMatchEnded = false;

    // Define a record to replace the tuple snapshot
    public record GameState(
        int UserPts,
        int OppPts,
        int UserG,
        int OppG,
        int UserS,
        int OppS,
        bool TieBreak,
        int DeuceCount,
        bool IsUserServing,
        int UserGamesSnapshot,
        int OpponentGamesSnapshot,
        List<SetScore>? SetScores,
        DateTime Timestamp,
        bool isComplete
    );

    // Initialize history with a GameState containing zeros and a null SetScores
    private Stack<GameState> history = new(new[] { new GameState(0, 0, 0, 0, 0, 0, false, 0, false, 0, 0, new List<SetScore>(), DateTime.Now, false) });

    // Add this field to store set scores
    private List<SetScore> setScores = new();

    private string ScoreDisplayOpp
    {
        get
        {
            if (isTieBreak)
                return $"{opponentPoints}";

            if (userPoints >= 3 && opponentPoints >= 3)
            {
                if (userPoints == opponentPoints)
                    return (userPoints == 3) ? "40" : "D";
                if (userPoints == opponentPoints + 1) return "";
                if (opponentPoints == userPoints + 1) return $"A({deuceCount})";
            }
            return $"{ConvertToTennisScore(opponentPoints)}";
        }
    }

    private string ScoreDisplayUser
    {
        get
        {
            if (isTieBreak)
                return $"{userPoints}";

            if (userPoints >= 3 && opponentPoints >= 3)
            {
                if (userPoints == opponentPoints)
                    return (userPoints == 3) ? "40" : "D";
                if (userPoints == opponentPoints + 1) return $"A({deuceCount})";
                if (opponentPoints == userPoints + 1) return "";
            }
            return $"{ConvertToTennisScore(userPoints)}";
        }
    }


    public class SetScore
    {
        public int SetNumber { get; set; }
        public int UserGames { get; set; }
        public int OpponentGames { get; set; }


        public SetScore Clone()
                => new SetScore
                {
                    UserGames = this.UserGames,
                    OpponentGames = this.OpponentGames,
                    SetNumber = this.SetNumber,
                };

    }

    public class Match
    {
        public Stack<GameState> History { get; set; } = new Stack<GameState>();
        public List<GameState> HistoryList { get; set; } = new List<GameState>();
        public string Player1 { get; set; }
        public string Player2 { get; set; }
        public string Player3 { get; set; }
        public string Player4 { get; set; }
        public bool Complete { get; set; }
    }

    public class SavedMatch
    {
        public int SavedMatchId { get; set; }
        public string MatchJson { get; set; }
        public bool Complete { get; set; }


    }

    [Inject] private IDbContextFactory<MyDbContext> DbFactory { get; set; }
    private bool isSaving;

    private async void SaveHistory()
    {
        // Push a snapshot using the GameState record. Clone setScores to avoid shared references.
     
        var snapshotList = setScores.Select(s => s.Clone()).ToList();

        history.Push(new GameState(userPoints, opponentPoints, userGames, opponentGames, userSets, opponentSets, isTieBreak, deuceCount, isUserServing, userGames, opponentGames, snapshotList, DateTime.Now, isMatchEnded));

        CurrentMatch.History = history;
        CurrentMatch.HistoryList = history.ToList();

        using var dbc = DbFactory.CreateDbContext();

        var matchToSave = await dbc.SavedMatch.FirstOrDefaultAsync();
        if (matchToSave == null)
        {
            matchToSave = new SavedMatch();
            dbc.SavedMatch.Add(matchToSave);
        }

        string currentMatchString = JsonConvert.SerializeObject(CurrentMatch);
        matchToSave.MatchJson = currentMatchString;
        matchToSave.Complete = CurrentMatch.Complete;
        await dbc.SaveChangesAsync();


        string json = JsonConvert.SerializeObject(history.Peek());

        if (hubConnection is not null)
        {
            hubConnection.SendAsync("SendMessage", $"{json}", "");
        }
    }

    private void UserWinsPoint()
    {
        if (isMatchEnded)
        {
            return;
        }    

        userPoints++;
        CheckGame();
        SaveHistory();
    }

    private void OpponentWinsPoint()
    {
        if (isMatchEnded)
        {
            return;
        }

        opponentPoints++;
        CheckGame();
        SaveHistory();
    }

    private void UndoLastPoint()
    {
        if (history.Any())
        {
            history.Pop();
        }
        if (history.Any())
        {
            var last = history.Peek();
            userPoints = last.UserPts;
            opponentPoints = last.OppPts;
            userGames = last.UserG;
            opponentGames = last.OppG;
            userSets = last.UserS;
            opponentSets = last.OppS;
            isTieBreak = last.TieBreak;
            deuceCount = last.DeuceCount;
            isMatchEnded = false;
            isUserServing = last.IsUserServing;
            setScores = last.SetScores != null ? last.SetScores.Select(s => s.Clone()).ToList() : new List<SetScore>();

        }
        CurrentMatch.Complete = false;
        isMatchEnded = false;
    }

    private void OpenSettings()
    {

    }

    private void CheckGame()
    {
        if (isTieBreak)
        {
            if ((userPoints >= 7 || opponentPoints >= 7) && Math.Abs(userPoints - opponentPoints) >= 2)
            {
                if (userPoints > opponentPoints)
                {
                    userGames++;
                    userSets++;
                }
                else
                {
                    opponentSets++;
                    opponentGames++;
                }
                EndSet();
            }

            var dsd = (userPoints + opponentPoints) % 2;

            if (dsd == 1)
                isUserServing = !isUserServing;
            return;
        }

        // Increment deuce count

        if (gameScoring)
        {
            if (userPoints > 0)
                userGames++;
            else
                opponentGames++;
            ResetGame();
            CheckSet();
            return;
        }


        if (userPoints >= 4 || opponentPoints >= 4)
        {
            int diff = userPoints - opponentPoints;

            if (!(deuceCount > maxDeuce))
            {
                // Normal tennis logic before deuce
                if (diff >= 2)
                {
                    userGames++;
                    ResetGame();
                    CheckSet();
                }
                else if (diff <= -2)
                {
                    opponentGames++;
                    ResetGame();
                    CheckSet();
                }
            }
            else
            {
                if (diff == 2 || diff == -2 || (diff == 1 && opponentPoints > 3) || (diff == -1 && userPoints > 3) || deuceCount > maxDeuce)
                {
                    if (diff > 0)
                        userGames++;
                    else
                        opponentGames++;
                    ResetGame();
                    CheckSet();
                }
            }
        }
        if (userPoints >= 3 && opponentPoints >= 3 && userPoints == opponentPoints)
            deuceCount += 1;
    }

    private void CheckSet()
    {
        if (userGames == 6 && opponentGames == 6)
        {
            isTieBreak = true;
            userPoints = opponentPoints = 0;
            return;
        }

        if ((userGames >= 6 || opponentGames >= 6) && Math.Abs(userGames - opponentGames) >= 2)
        {
            if (userGames > opponentGames)
                userSets++;
            else
                opponentSets++;

            EndSet();
        }
    }

    private int GetMaxSetsToWin(int bestOf)
    {
        switch (bestOf)
        {
            case 3:
                return 2;
            case 5:
                return 3;
            case 7:
                return 4;
            default:
                return 0;
        }
    }

    private void EndSet()
    {
        setScores.Add(new SetScore { SetNumber = setScores.Count() + 1, UserGames = userGames, OpponentGames = opponentGames }); // Save completed set score
        userGames = opponentGames = 0;
        userPoints = opponentPoints = 0;
        isTieBreak = false;

        // Check match win condition dynamically
        if (userSets == GetMaxSetsToWin(bestOf) || opponentSets == GetMaxSetsToWin(bestOf))
        {
            EndMatch();
            // ResetMatch();
        }
    }

    private void EndMatch()
    {
        isMatchEnded = true;
        // SaveHistory();
        CurrentMatch.Complete = true;

        if(userSets > opponentSets)
        {
            _winner = CurrentMatch.Player1;
            if (Label_Switch1)
            {
                _winner += " & " + CurrentMatch.Player2;
            }
        }
        else
        {
            _winner = CurrentMatch.Player2;
            if (Label_Switch1)
            {
                _winner = CurrentMatch.Player3 + " & " + CurrentMatch.Player4;
            }
        };
        _winner = $"Congratulations {_winner}"; 
        Console.WriteLine(userSets > opponentSets ? "User wins the match!" : "Opponent wins the match!");
    }

    private void ResetGame()
    {
        userPoints = 0;
        opponentPoints = 0;
        isUserServing = !isUserServing;
        deuceCount = 0;
    }

    private void ResetMatch()
    {
        userPoints = opponentPoints = 0;
        userGames = opponentGames = 0;
        userSets = opponentSets = 0;
        isTieBreak = false;
        isMatchEnded = false;
        history.Clear();
    }

    private string ConvertToTennisScore(int points) => points switch
    {
        0 => "0",
        1 => "15",
        2 => "30",
        3 => "40",
        _ => "40"
    };
}