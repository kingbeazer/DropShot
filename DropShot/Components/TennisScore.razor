@using System.ComponentModel.DataAnnotations
@using DropShot.Models;
@using DropShot.Data;
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.EntityFrameworkCore
@using System;
@using System.Collections.Generic
@using System.Text.Json
@using Newtonsoft.Json

@page "/tennisscore"
@rendermode InteractiveServer
@inject MyDbContext DbContext
@inject NavigationManager Navigation

<div class="score-container">
    <!-- Top Player Button -->
    <button name="btnUserWinsPoint" class="initial-circle" @onclick="UserWinsPoint" disabled="@isMatchEnded">
        AB
    </button>
    <!-- Score Display -->
    <div class="score-display">
        <div class="score-row">

            @if (isUserServing)
            {
                <span class="sets serve-indicator">🎾</span>
            }
            else
            {
                <span class="sets serve-indicator"></span>
            }

            @foreach (var set in setScores)
            {
                <span class="sets">@set.UserGames</span>
            }

            <span class="sets">@userGames</span><span class="sets">@ScoreDisplayUser</span>
        </div>
        <div class="score-row">

            @if (!isUserServing)
            {
                <span class="sets serve-indicator">🎾</span>
            }
            else
            {
                <span class="sets serve-indicator"></span>
            }

              @foreach (var set in setScores)
    {
                <span class="sets">@set.OpponentGames </span>
    }

            <span class="sets">@opponentGames</span><span class="sets">@ScoreDisplayOpp</span>
        </div>


        <!-- Settings Button (Bottom Left) -->
        <button class="settings-btn" @onclick="OpenSettings">
            ⚙️
        </button>

        <!-- Undo Button (Bottom Right) -->
        <button class="undo-btn" @onclick="UndoLastPoint">
            ⤺
        </button>

    </div>



    <!-- Bottom Player Button -->
    <button name="btnOppWinsPoint" class="initial-circle" @onclick="OpponentWinsPoint" disabled="@isMatchEnded">
        AB
    </button>
</div>

   <div>
       <span></span></div>

<div style="display: flex">
    @foreach (var set in setScores)
    {
        <DotDigit Number="@set.UserGames" />
    }
</div>

<div style="display: flex">
    @foreach (var set in setScores)
    {
        <DotDigit Number="@set.OpponentGames" />
    }
</div>

@code {
    private int userPoints = 0;
    private int opponentPoints = 0;
    private int userGames = 0;
    private int opponentGames = 0;
    private int userSets = 0;
    private int opponentSets = 0;
    private bool isTieBreak = false;
    private int bestOf = 5;
    private int gamesFirstTo = 6;
    private bool gameScoring = true;
    private int maxDeuce = 99999;
    private bool isUserServing = true; // Start with user serving
    private List<Score> scores = new();
    private HubConnection? hubConnection;

    protected override async Task OnInitializedAsync()
    {
        scores = await DbContext.Score.ToListAsync();

        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/chathub"))
            .Build();

        hubConnection.On<string, string>( "ReceiveMessage", async (user, message) =>
        {
            scores = await DbContext.Score.ToListAsync();

            await InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();
    }

    private int deuceCount = 0;
    private bool isMatchEnded = false;

    // Define a record to replace the tuple snapshot
    public record GameState(
        int UserPts,
        int OppPts,
        int UserG,
        int OppG,
        int UserS,
        int OppS,
        bool TieBreak,
        int DeuceCount,
        bool IsUserServing,
        int UserGamesSnapshot,
        int OpponentGamesSnapshot,
        List<SetScore>? SetScores
    );

    // Initialize history with a GameState containing zeros and a null SetScores
    private Stack<GameState> history = new(new[] { new GameState(0, 0, 0, 0, 0, 0, false, 0, false, 0, 0, new List<SetScore>()) });

    // Add this field to store set scores
    private List<SetScore> setScores = new();

    private string ScoreDisplayOpp
    {
        get
        {
            if (isTieBreak)
                return $"{opponentPoints}";

            if (userPoints >= 3 && opponentPoints >= 3)
            {
                if (userPoints == opponentPoints)
                    return (userPoints == 3) ? "40" : "D";
                if (userPoints == opponentPoints + 1) return "";
                if (opponentPoints == userPoints + 1) return $"A({deuceCount})";
            }
            return $"{ConvertToTennisScore(opponentPoints)}";
        }
    }

    private string ScoreDisplayUser
    {
        get
        {
            if (isTieBreak)
                return $"{userPoints}";

            if (userPoints >= 3 && opponentPoints >= 3)
            {
                if (userPoints == opponentPoints)
                    return (userPoints == 3) ? "40" : "D";
                if (userPoints == opponentPoints + 1) return $"A({deuceCount})";
                if (opponentPoints == userPoints + 1) return "";
            }
            return $"{ConvertToTennisScore(userPoints)}";
        }
    }


    public class SetScore
    {
        public int SetNumber { get; set; }
        public int UserGames { get; set; }
        public int OpponentGames { get; set; }
    }



    private void SaveHistory()
    {
        // Push a snapshot using the GameState record. Clone setScores to avoid shared references.
        var setsClone = setScores is null ? null : new List<SetScore>(setScores);
        history.Push(new GameState(userPoints, opponentPoints, userGames, opponentGames, userSets, opponentSets, isTieBreak, deuceCount, isUserServing, userGames, opponentGames, setsClone));

        string json = JsonConvert.SerializeObject(history.Peek());

        if (hubConnection is not null)
        {
            hubConnection.SendAsync("SendMessage", $"{json}", "");
        }
    }

    private void UserWinsPoint()
    {
        userPoints++;
        CheckGame();
        SaveHistory();
    }

    private void OpponentWinsPoint()
    {
        opponentPoints++;
        CheckGame();
        SaveHistory();
    }

    private void UndoLastPoint()
    {
        if (history.Any())
        {
            history.Pop();
        }
        if (history.Any())
        {
            var last = history.Peek();
            userPoints = last.UserPts;
            opponentPoints = last.OppPts;
            userGames = last.UserG;
            opponentGames = last.OppG;
            userSets = last.UserS;
            opponentSets = last.OppS;
            isTieBreak = last.TieBreak;
            deuceCount = last.DeuceCount;
            isMatchEnded = false;
            isUserServing = last.IsUserServing;
            setScores = last.SetScores ?? new List<SetScore>();
        }
    }

    private void OpenSettings()
    {

    }

    private void CheckGame()
    {
        if (isTieBreak)
        {
            if ((userPoints >= 7 || opponentPoints >= 7) && Math.Abs(userPoints - opponentPoints) >= 2)
            {
                if (userPoints > opponentPoints)
                {
                    userGames++;
                    userSets++;
                }
                else
                {
                    opponentSets++;
                    opponentGames++;
                }
                EndSet();
            }

            var dsd = (userPoints + opponentPoints) % 2;

            if  (dsd == 1)
                isUserServing = !isUserServing; 
            return;
        }

        // Increment deuce count

        if (gameScoring)
        {
            if (userPoints > 0)
                userGames++;
            else
                opponentGames++;
            ResetGame();
            CheckSet();
            return;
        }


        if (userPoints >= 4 || opponentPoints >= 4)
        {
            int diff = userPoints - opponentPoints;

            if (!(deuceCount > maxDeuce))
            {
                // Normal tennis logic before deuce
                if (diff >= 2)
                {
                    userGames++;
                    ResetGame();
                    CheckSet();
                }
                else if (diff <= -2)
                {
                    opponentGames++;
                    ResetGame();
                    CheckSet();
                }
            }
            else
            {
                if (diff == 2 || diff == -2 || (diff == 1 && opponentPoints > 3) || (diff == -1 && userPoints > 3) || deuceCount > maxDeuce)
                {
                    if (diff > 0)
                        userGames++;
                    else
                        opponentGames++;
                    ResetGame();
                    CheckSet();
                }
            }
        }
        if (userPoints >= 3 && opponentPoints >= 3 && userPoints == opponentPoints)
            deuceCount += 1;
    }

    private void CheckSet()
    {
        if (userGames == 6 && opponentGames == 6)
        {
            isTieBreak = true;
            userPoints = opponentPoints = 0;
            return;
        }

        if ((userGames >= 6 || opponentGames >= 6) && Math.Abs(userGames - opponentGames) >= 2)
        {
            if (userGames > opponentGames)
                userSets++;
            else
                opponentSets++;

            EndSet();
        }
    }

    private int GetMaxSetsToWin(int bestOf)
    {
        switch (bestOf)
        {
            case 3:
                return 2;
            case 5:
                return 3;
            case 7:
                return 4;
            default:
                return 0;
        }
    }

    private void EndSet()
    {
        setScores.Add(new SetScore { SetNumber = setScores.Count() + 1, UserGames = userGames, OpponentGames = opponentGames }); // Save completed set score
        userGames = opponentGames = 0;
        userPoints = opponentPoints = 0;
        isTieBreak = false;

        // Check match win condition dynamically
        if (userSets == GetMaxSetsToWin(bestOf) || opponentSets == GetMaxSetsToWin(bestOf))
        {
            EndMatch();
            // ResetMatch();
        }
    }

    private void EndMatch()
    {
        isMatchEnded = true;
        Console.WriteLine(userSets > opponentSets ? "User wins the match!" : "Opponent wins the match!");
    }

    private void ResetGame()
    {
        userPoints = 0;
        opponentPoints = 0;
        isUserServing = !isUserServing;
        deuceCount = 0;
    }

    private void ResetMatch()
    {
        userPoints = opponentPoints = 0;
        userGames = opponentGames = 0;
        userSets = opponentSets = 0;
        isTieBreak = false;
        isMatchEnded = false;
        history.Clear();
    }

    private string ConvertToTennisScore(int points) => points switch
    {
        0 => "0",
        1 => "15",
        2 => "30",
        3 => "40",
        _ => "40"
    };
}