@using System.ComponentModel.DataAnnotations
@using DropShot.Models;
@using DropShot.Data;
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.EntityFrameworkCore
@using System;
@using System.Collections.Generic
@using System.Text.Json
@using Newtonsoft.Json
@using MudBlazor
@using System.Threading

@page "/tennisscore"
@rendermode InteractiveServer
 

@inject NavigationManager Navigation

@if (currentMatch == null)
{
     
         

    <MudSwitch @bind-Value="Label_Switch1" Label="Doubles" Color="Color.Success" />


    <MudAutocomplete @bind-Value="_value"
                     Label="Player 1"
                     SearchFunc="@Search1"
                     ResetValueOnEmptyText="@resetValueOnEmptyText"
                     Variant="Variant.Outlined"
                     CoerceText="@coerceText"
                     Margin="_margin"
                     Dense="_dense"
                     CoerceValue="true"
                     Placeholder="@(_placeholder ? "Placeholder" : null)"
                     SelectValueOnTab="@selectedOnTab"
                     AdornmentColor="Color.Primary" />
    @if (!Label_Switch1)
    {
        <MudText Typo="Typo.h1">vs</MudText>
    }
    <MudAutocomplete @bind-Value="_value2"
                     Label="Player 2"
                     SearchFunc="@Search1"
                     ResetValueOnEmptyText="@resetValueOnEmptyText"
                     Variant="Variant.Outlined"
                     CoerceText="@coerceText"
                     Margin="_margin"
                     Dense="_dense"
                     CoerceValue="true"
                     Placeholder="@(_placeholder ? "Placeholder" : null)"
                     SelectValueOnTab="@selectedOnTab"
                     AdornmentColor="Color.Primary" />

    @if (Label_Switch1)
    {
        <MudText Typo="Typo.h1">vs</MudText>
    }

    @if (Label_Switch1)
    {
        <MudAutocomplete @bind-Value="_value3"
                         Label="Player 3"
                         SearchFunc="@Search1"
                         ResetValueOnEmptyText="@resetValueOnEmptyText"
                         Variant="Variant.Outlined"
                         CoerceText="@coerceText"
                         Margin="_margin"
                         Dense="_dense"
                         CoerceValue="true"
                         Placeholder="@(_placeholder ? "Placeholder" : null)"
                         SelectValueOnTab="@selectedOnTab"
                         AdornmentColor="Color.Primary" />

        <MudAutocomplete @bind-Value="_value4"
                         Label="Player 4"
                         SearchFunc="@Search1"
                         ResetValueOnEmptyText="@resetValueOnEmptyText"
                         Variant="Variant.Outlined"
                         CoerceText="@coerceText"
                         Margin="_margin"
                         Dense="_dense"
                         CoerceValue="true"
                         Placeholder="@(_placeholder ? "Placeholder" : null)"
                         SelectValueOnTab="@selectedOnTab"
                         AdornmentColor="Color.Primary" />
    }



    <MudButton Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.PlayArrow" Style="margin: 10px;" OnClick="ButtonOnClick">Start Match</MudButton>
          
  

}
else
{

    <div class="score-container">
        <!-- Top Player Button -->
        <div style="display: flex">
            <MudAvatar @onclick="UserWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px lightseagreen; width:100px; height: 100px;">
                <MudImage Src="images/me.png"></MudImage>
                <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                                    color:white; font-size:14px; font-weight:bold;">
                    @_value.GetInitials()
                </div>
            </MudAvatar>
           
            @if (Label_Switch1)
            {
                <MudAvatar @onclick="UserWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px lightseagreen; width:100px; height: 100px; margin-left: -15px;">
                    <MudImage Src="images/me.png" @onclick="UserWinsPoint"></MudImage>
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                                            color:white; font-size:14px; font-weight:bold;">
                        @_value2.GetInitials()
                    </div>
                </MudAvatar>
            }
        </div>
        <!-- Score Display -->
        <div class="score-display">
            <div class="score-row">

                @if (isUserServing)
                {
                    <span class="sets serve-indicator">🎾</span>
                }
                else
                {
                    <span class="sets serve-indicator"></span>
                }

                @foreach (var set in setScores)
                {
                    <span class="sets">@set.UserGames</span>
                }
                @if (!isMatchEnded)
                {
                    <span class="sets">@userGames</span>
                }
                @if (!gameScoring || isTieBreak)
                {
                    <span class="sets">@ScoreDisplayUser</span>
                }
            </div>
            <div class="score-row">

                @if (!isUserServing)
                {
                    <span class="sets serve-indicator">🎾</span>
                }
                else
                {
                    <span class="sets serve-indicator"></span>
                }

                @foreach (var set in setScores)
                {
                    <span class="sets">@set.OpponentGames </span>
                }

                @if (!isMatchEnded)
                {
                    <span class="sets">@opponentGames</span>
                }

                @if (!gameScoring || isTieBreak)
                {
                    <span class="sets">@ScoreDisplayOpp</span>
                }
            </div>


            <!-- Settings Button (Bottom Left) -->
            <button class="settings-btn" @onclick="OpenSettings">
                ⚙️
            </button>

            <!-- Undo Button (Bottom Right) -->
            <button class="undo-btn" @onclick="UndoLastPoint">
                ⤺
            </button>

        </div>



        <!-- Bottom Player Button -->
        <div style="display: flex">
            @if (Label_Switch1)
            {
                <MudAvatar @onclick="OpponentWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px orangered; width:100px; height: 100px;">
                    <MudImage Src="images/me.png"></MudImage>
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                                color:white; font-size:14px; font-weight:bold;">
                        @_value3.GetInitials()
                    </div>
                </MudAvatar>
                <MudAvatar @onclick="OpponentWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px orangered; width:100px; height: 100px; margin-left: -15px;">
                    <MudImage Src="images/me.png"></MudImage>
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                                color:white; font-size:14px; font-weight:bold;">
                        @_value4.GetInitials()
                    </div>
                </MudAvatar>
            }
            else
            {
                <MudAvatar @onclick="OpponentWinsPoint" disabled="@isMatchEnded" Style="border: solid 2px orangered; width:100px; height: 100px;">
                    <MudImage Src="images/me.png"></MudImage>
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                        color:white; font-size:14px; font-weight:bold;">
                        @_value2.GetInitials()
                    </div>
                </MudAvatar>

              @*   <button name="btnOppWinsPoint" class="initial-circle" style="color: lightseagreen; border-color: lightseagreen" >
                    <MudImage Src="images/me.png" Alt="Mony the dog" ObjectFit="@ObjectFit.Contain" Elevation="25" Class="rounded-lg" />
                </button> *@

            }
        </div>
    </div>

    <div>
        <span></span>
    </div>

    <div style="display: flex">
        @foreach (var set in setScores)
        {
            <DotDigit Number="@set.UserGames" />
        }
    </div>

    <div style="display: flex">
        @foreach (var set in setScores)
        {
            <DotDigit Number="@set.OpponentGames" />
        }
    </div>
}

@code {



    private string _value;
    private string _value2;
    private string _value3;
    private string _value4;
    private Margin _margin;
    private bool _dense;
    private bool _disabled;
    private bool _readonly;
    private bool _placeholder;
    private bool _helperText;
    private bool _helperTextOnFocus;
    private bool _clearable;
    private bool _modal = true;
    private string Image = "images/me.png";


    private bool resetValueOnEmptyText;
    private bool coerceText;
    private bool coerceValue;
    private bool selectedOnTab;


    private async Task<IEnumerable<string>> Search1(string value, CancellationToken token)
    {
        // In real life use an asynchronous function for fetching data from an api.
        await Task.Delay(5, token);

        // if text is null or empty, show complete list
        if (string.IsNullOrEmpty(value))
            return _states;
        return _states.Where(x => x.Contains(value, StringComparison.InvariantCultureIgnoreCase));
    }

    private async Task<IEnumerable<string>> Search2(string value, CancellationToken token)
    {
        // In real life use an asynchronous function for fetching data from an api.
        await Task.Delay(5, token);

        // if text is null or empty, don't return values (drop-down will not open)
        if (string.IsNullOrEmpty(value))
            return new string[0];
        return _states.Where(x => x.Contains(value, StringComparison.InvariantCultureIgnoreCase));
    }


    public bool Label_Switch1 { get; set; } = false;

    void ButtonOnClick()
    {
        currentMatch = new Match
        {
            History = history,
            Player1 = _value,
            Player2 = _value2,
            Player3 = _value3,
            Player4 = _value4
        };
    }

    private string[] _states =
    {
        "Alan Beattie", "Andrew Beattie", "Mark Buchner", "Kevin Beathie", "Ronald Beattie",
        "Ian Kerr", "James Daniel"
    };

    private async Task<IEnumerable<string>> Search(string value, CancellationToken token)
    {
        // In real life use an asynchronous function for fetching data from an api.
        await Task.Delay(5, token);

        // if text is null or empty, show complete list
        if (string.IsNullOrEmpty(value))
        {
            return new List<string>();
        }

        return _states.Where(x => x.Contains(value, StringComparison.InvariantCultureIgnoreCase));
    }

    private int userPoints = 0;
    private int opponentPoints = 0;
    private int userGames = 0;
    private int opponentGames = 0;
    private int userSets = 0;
    private int opponentSets = 0;
    private bool isTieBreak = false;
    private int bestOf = 5;
    private int gamesFirstTo = 6;
    private bool gameScoring = true;
    private int maxDeuce = 99999;
    private bool isUserServing = true; // Start with user serving
    private List<Score> scores = new();
    private HubConnection? hubConnection;
    private bool matchGo = false;
    private Match currentMatch;

    protected override async Task OnInitializedAsync()
    {

        using var dbc = DbFactory.CreateDbContext();

        var savedMatch = await dbc.SavedMatch.FirstOrDefaultAsync();

        // Fix CS8602: Check for null before dereferencing savedMatch
        if (savedMatch != null && !string.IsNullOrEmpty(savedMatch.MatchJson))
        {
            // Fix CS0266: Specify the type parameter for DeserializeObject
            // Fix CS8601: Use null-forgiving operator if you are sure MatchJson is not null, or handle null
            currentMatch = JsonConvert.DeserializeObject<Match>(savedMatch.MatchJson) ?? new Match();
            history = currentMatch.History;

            if (history.Any())
            {
                var last = history.Last();
                userPoints = last.UserPts;
                opponentPoints = last.OppPts;
                userGames = last.UserG;
                opponentGames = last.OppG;
                userSets = last.UserS;
                opponentSets = last.OppS;
                isTieBreak = last.TieBreak;
                deuceCount = last.DeuceCount;
                isMatchEnded = false;
                isUserServing = last.IsUserServing;
                setScores = last.SetScores ?? new List<SetScore>();
            }
        }


        scores = await dbc.Score.ToListAsync();

        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/chathub"))
            .Build();

        hubConnection.On<string, string>("ReceiveMessage", async (user, message) =>
        {
            scores = await dbc.Score.ToListAsync();

            await InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();
    }

    private int deuceCount = 0;
    private bool isMatchEnded = false;

    // Define a record to replace the tuple snapshot
    public record GameState(
        int UserPts,
        int OppPts,
        int UserG,
        int OppG,
        int UserS,
        int OppS,
        bool TieBreak,
        int DeuceCount,
        bool IsUserServing,
        int UserGamesSnapshot,
        int OpponentGamesSnapshot,
        List<SetScore>? SetScores,
        DateTime Timestamp
    );

    // Initialize history with a GameState containing zeros and a null SetScores
    private Stack<GameState> history = new(new[] { new GameState(0, 0, 0, 0, 0, 0, false, 0, false, 0, 0, new List<SetScore>(), DateTime.Now) });

    // Add this field to store set scores
    private List<SetScore> setScores = new();

    private string ScoreDisplayOpp
    {
        get
        {
            if (isTieBreak)
                return $"{opponentPoints}";

            if (userPoints >= 3 && opponentPoints >= 3)
            {
                if (userPoints == opponentPoints)
                    return (userPoints == 3) ? "40" : "D";
                if (userPoints == opponentPoints + 1) return "";
                if (opponentPoints == userPoints + 1) return $"A({deuceCount})";
            }
            return $"{ConvertToTennisScore(opponentPoints)}";
        }
    }

    private string ScoreDisplayUser
    {
        get
        {
            if (isTieBreak)
                return $"{userPoints}";

            if (userPoints >= 3 && opponentPoints >= 3)
            {
                if (userPoints == opponentPoints)
                    return (userPoints == 3) ? "40" : "D";
                if (userPoints == opponentPoints + 1) return $"A({deuceCount})";
                if (opponentPoints == userPoints + 1) return "";
            }
            return $"{ConvertToTennisScore(userPoints)}";
        }
    }


    public class SetScore
    {
        public int SetNumber { get; set; }
        public int UserGames { get; set; }
        public int OpponentGames { get; set; }
    }

    public class Match
    {
        public Stack<GameState> History { get; set; }
        public string Player1 { get; set; }
        public string Player2 { get; set; }
        public string Player3 { get; set; }
        public string Player4 { get; set; }
    }

    public class SavedMatch
    {
        public int SavedMatchId { get; set; }
        public string MatchJson { get; set; }

    }

    [Inject] private IDbContextFactory<MyDbContext> DbFactory { get; set; }
    private bool isSaving;

    private async void SaveHistory()
    {
        // Push a snapshot using the GameState record. Clone setScores to avoid shared references.
        var setsClone = setScores is null ? null : new List<SetScore>(setScores);
        history.Push(new GameState(userPoints, opponentPoints, userGames, opponentGames, userSets, opponentSets, isTieBreak, deuceCount, isUserServing, userGames, opponentGames, setsClone, DateTime.Now));

        currentMatch.History = history;

        using var dbc = DbFactory.CreateDbContext();

        var matchToSave = await dbc.SavedMatch.FirstOrDefaultAsync();
        if (matchToSave == null)
        {
            matchToSave = new SavedMatch();
            dbc.SavedMatch.Add(matchToSave);
        }
        string currentMatchString = JsonConvert.SerializeObject(currentMatch);
        matchToSave.MatchJson = currentMatchString;
        await dbc.SaveChangesAsync();


        string json = JsonConvert.SerializeObject(history.Peek());

        if (hubConnection is not null)
        {
            hubConnection.SendAsync("SendMessage", $"{json}", "");
        }
    }

    private void UserWinsPoint()
    {
        if (isMatchEnded)
            return;
        userPoints++;
        CheckGame();
        SaveHistory();
    }

    private void OpponentWinsPoint()
    {
        if (isMatchEnded)
            return;
        opponentPoints++;
        CheckGame();
        SaveHistory();
    }

    private void UndoLastPoint()
    {
        if (history.Any())
        {
            history.Pop();
        }
        if (history.Any())
        {
            var last = history.Peek();
            userPoints = last.UserPts;
            opponentPoints = last.OppPts;
            userGames = last.UserG;
            opponentGames = last.OppG;
            userSets = last.UserS;
            opponentSets = last.OppS;
            isTieBreak = last.TieBreak;
            deuceCount = last.DeuceCount;
            isMatchEnded = false;
            isUserServing = last.IsUserServing;
            setScores = last.SetScores ?? new List<SetScore>();
        }
    }

    private void OpenSettings()
    {

    }

    private void CheckGame()
    {
        if (isTieBreak)
        {
            if ((userPoints >= 7 || opponentPoints >= 7) && Math.Abs(userPoints - opponentPoints) >= 2)
            {
                if (userPoints > opponentPoints)
                {
                    userGames++;
                    userSets++;
                }
                else
                {
                    opponentSets++;
                    opponentGames++;
                }
                EndSet();
            }

            var dsd = (userPoints + opponentPoints) % 2;

            if (dsd == 1)
                isUserServing = !isUserServing;
            return;
        }

        // Increment deuce count

        if (gameScoring)
        {
            if (userPoints > 0)
                userGames++;
            else
                opponentGames++;
            ResetGame();
            CheckSet();
            return;
        }


        if (userPoints >= 4 || opponentPoints >= 4)
        {
            int diff = userPoints - opponentPoints;

            if (!(deuceCount > maxDeuce))
            {
                // Normal tennis logic before deuce
                if (diff >= 2)
                {
                    userGames++;
                    ResetGame();
                    CheckSet();
                }
                else if (diff <= -2)
                {
                    opponentGames++;
                    ResetGame();
                    CheckSet();
                }
            }
            else
            {
                if (diff == 2 || diff == -2 || (diff == 1 && opponentPoints > 3) || (diff == -1 && userPoints > 3) || deuceCount > maxDeuce)
                {
                    if (diff > 0)
                        userGames++;
                    else
                        opponentGames++;
                    ResetGame();
                    CheckSet();
                }
            }
        }
        if (userPoints >= 3 && opponentPoints >= 3 && userPoints == opponentPoints)
            deuceCount += 1;
    }

    private void CheckSet()
    {
        if (userGames == 6 && opponentGames == 6)
        {
            isTieBreak = true;
            userPoints = opponentPoints = 0;
            return;
        }

        if ((userGames >= 6 || opponentGames >= 6) && Math.Abs(userGames - opponentGames) >= 2)
        {
            if (userGames > opponentGames)
                userSets++;
            else
                opponentSets++;

            EndSet();
        }
    }

    private int GetMaxSetsToWin(int bestOf)
    {
        switch (bestOf)
        {
            case 3:
                return 2;
            case 5:
                return 3;
            case 7:
                return 4;
            default:
                return 0;
        }
    }

    private void EndSet()
    {
        setScores.Add(new SetScore { SetNumber = setScores.Count() + 1, UserGames = userGames, OpponentGames = opponentGames }); // Save completed set score
        userGames = opponentGames = 0;
        userPoints = opponentPoints = 0;
        isTieBreak = false;

        // Check match win condition dynamically
        if (userSets == GetMaxSetsToWin(bestOf) || opponentSets == GetMaxSetsToWin(bestOf))
        {
            EndMatch();
            // ResetMatch();
        }
    }

    private void EndMatch()
    {
        isMatchEnded = true;
        Console.WriteLine(userSets > opponentSets ? "User wins the match!" : "Opponent wins the match!");
    }

    private void ResetGame()
    {
        userPoints = 0;
        opponentPoints = 0;
        isUserServing = !isUserServing;
        deuceCount = 0;
    }

    private void ResetMatch()
    {
        userPoints = opponentPoints = 0;
        userGames = opponentGames = 0;
        userSets = opponentSets = 0;
        isTieBreak = false;
        isMatchEnded = false;
        history.Clear();
    }

    private string ConvertToTennisScore(int points) => points switch
    {
        0 => "0",
        1 => "15",
        2 => "30",
        3 => "40",
        _ => "40"
    };
}